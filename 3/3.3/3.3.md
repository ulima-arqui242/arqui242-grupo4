# 3.3. Modelo de Datos

# Decisión de Modelado de Datos

## Contexto
El proyecto contiene varios módulos clave (gestión de pagos, reservas, solicitudes, capital, junta de inquilinos, notificaciones), donde algunos requieren relaciones complejas y consistencia de datos (p. ej., pagos, reservas) y otros pueden beneficiarse de una mayor flexibilidad (p. ej., notificaciones, solicitudes). El sistema debe ser eficiente y escalable, con la capacidad de manejar tanto datos estructurados como semiestructurados.

## Alternativas

### Modelo Relacional con Tablas Normalizadas (PostgreSQL)
**Ventajas**:
- Eficiente para consultas complejas y relaciones claras entre entidades.
- Mantenimiento de la integridad referencial.

**Desventajas**:
- Más rígido al manejar datos no estructurados o semiestructurados.

### Modelo No Relacional (MongoDB)
**Ventajas**:
- Flexibilidad para manejar datos sin esquema fijo (p. ej., logs de notificaciones o preferencias personalizadas).
- Buen rendimiento en lecturas rápidas.

**Desventajas**:
- Menor capacidad para manejar relaciones complejas de manera eficiente.
- Dificultad para mantener integridad referencial.

### Modelo Híbrido (Relacional + No Relacional)
**Ventajas**:
- Lo mejor de ambos enfoques: estructura sólida con PostgreSQL para datos estructurados y flexibilidad de MongoDB para módulos que requieren esquemas más dinámicos.
- Escalabilidad y adaptabilidad según las necesidades del módulo.

**Desventajas**:
- Mayor complejidad en la implementación y sincronización entre dos bases de datos.
- Requiere mantener dos sistemas diferentes.

## Criterios de Elección
- **Relaciones complejas y consistencia**: para módulos como "Gestión de pagos" y "Gestión de reservas".
- **Flexibilidad y escalabilidad**: para módulos más dinámicos como "Notificaciones" o "Solicitudes".
- **Rendimiento en consultas y eficiencia**: consultas de datos relacionados y visualización de reportes financieros.
- **Seguridad y gestión de transacciones**: en el procesamiento de pagos y manejo de datos sensibles.

## Decisión
Se elige un **modelo híbrido**, utilizando **PostgreSQL** para los módulos que requieren integridad referencial y relaciones complejas (pagos, reservas, capital) y **MongoDB** para los módulos que requieren mayor flexibilidad y manejo de datos semiestructurados (notificaciones, solicitudes).

## Sustento
El modelo relacional de PostgreSQL se utilizará en módulos que requieren integridad y relaciones complejas, como pagos y reservas, mientras que MongoDB será ideal para módulos más flexibles como notificaciones y solicitudes, donde los esquemas pueden cambiar con frecuencia y los datos semiestructurados se gestionan de manera más eficiente.


# Decisión sobre el uso de ORM

## Contexto
El proyecto requiere la integración de una base de datos relacional (PostgreSQL) y una no relacional (MongoDB) para gestionar distintos módulos. Dado que el sistema manejará un alto volumen de operaciones y entidades relacionadas, es crucial elegir una herramienta que facilite el manejo de estas bases de datos. Se está considerando el uso de un ORM (Object-Relational Mapping) para simplificar las interacciones con PostgreSQL y una herramienta adecuada para MongoDB.

## Alternativas

### TypeORM (para PostgreSQL)
**Ventajas**:
- Compatible con PostgreSQL, MySQL, SQLite, y otros.
- Admite migraciones de esquemas y decoradores de TypeScript.
- Facilita el manejo de relaciones complejas entre entidades.
- Soporte activo y comunidad en crecimiento.

**Desventajas**:
- Puede ser más lento en consultas complejas debido a la abstracción del ORM.
- Mayor tiempo de configuración en comparación con consultas SQL directas.

### Sequelize (para PostgreSQL)
**Ventajas**:
- Amplia documentación y soporte.
- Más flexible en la configuración de consultas avanzadas.
- Soporte para múltiples bases de datos relacionales.

**Desventajas**:
- No tiene soporte nativo para TypeScript (aunque existen paquetes externos).
- El manejo de relaciones complejas puede ser más difícil que en TypeORM.

### Mongoose (para MongoDB)
**Ventajas**:
- Ideal para el manejo de esquemas dinámicos en MongoDB.
- Popular y ampliamente utilizado con una gran comunidad de soporte.
- Soporta validaciones, middlewares, y esquemas anidados.

**Desventajas**:
- La curva de aprendizaje puede ser alta para usuarios sin experiencia en MongoDB.
- Menos control sobre consultas complejas en comparación con operaciones nativas.

### Consultas SQL/NoSQL Directas
**Ventajas**:
- Máximo control sobre las consultas y optimización manual.
- Sin capas adicionales de abstracción, lo que puede mejorar el rendimiento.

**Desventajas**:
- Mayor complejidad en el código, especialmente al manejar relaciones.
- Requiere escribir más lógica manualmente, lo que puede llevar a un código difícil de mantener a largo plazo.

## Criterios de Elección
- Facilidad para manejar relaciones entre entidades en PostgreSQL.
- Soporte para TypeScript, ya que el proyecto se desarrollará en esta tecnología.
- Necesidad de simplificar las interacciones con MongoDB, aprovechando su flexibilidad.
- Velocidad de desarrollo y mantenibilidad a largo plazo.

## Decisión
Se elige **TypeORM** para la base de datos relacional **PostgreSQL** y **Mongoose** para la base de datos no relacional **MongoDB**. 

## Sustento
**TypeORM** se elige para PostgreSQL debido a su compatibilidad con TypeScript, soporte nativo para relaciones complejas y la capacidad de manejar migraciones de base de datos, lo cual es esencial para los módulos que requieren integridad y consistencia de datos. **Mongoose** es ideal para manejar la flexibilidad y los datos semiestructurados en MongoDB, permitiendo a los módulos dinámicos como notificaciones y solicitudes gestionar cambios frecuentes en los esquemas de manera eficiente.




![modelo_arq](modelo_datos_arq_(2).png)
