# 9.2. Iteración 1: Definir la estructura general del sistema

### Paso 1: Revisar Entradas

| **Propósito de Diseño**     | **Funcionalidad Primaria**     | **Escenarios de Calidad**       | **Restricciones y Preocupaciones de Arquitectura**      |
|-----------------------------|--------------------------------|---------------------------------|-------------------------------------------------------|
| Crear el diseño desde cero  | CU01, CU02, CU05, CU06      | QA-01, QA-02, QA-04          | CON-01, CON-02, CON-04, CON-05, CON-07, CRN-01, CRN-02 |

### Paso 2: Establecer objetivo de la iteración

Establecer la estructura inicial y funcional del sistema que permita realizar el flujo operativo básico. Generar la estructura inicial y funcional de nuestro sistema para que se pueda hacer el flujo principal de la aplicación **Homesync**, el cual visualiza los departamentos, los reserva y realiza el pago.

### Paso 3: Elegir uno o más elementos del sistema a refinar

#### Diagrama de contexto

Realizando la arquitectura desde cero se tiene para comenzar un diagrama de contexto que representa un sistema de gestión de edificios utilizando el modelo C4.

![Diagrama de contexto](contexto.png)

### Paso 4: Elegir uno o más conceptos de diseño que satisfacen el driver seleccionado

| Código  | Concepto de diseño                                        | Fundamentación                                                                                                                                                                         |
|---------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **DEC-01**  | Arquitectura basada en microservicios                      | La elección de microservicios responde a la necesidad de crear un sistema escalable, que permita manejar múltiples funcionalidades (como reservas y pagos) de forma independiente. Los microservicios abordan la preocupación sobre escalabilidad y rendimiento (CRN-01, CRN-02) y permiten una mejor distribución de la carga de trabajo entre los servicios. Además, cumplen con los requisitos de calidad relacionados con la capacidad de manejar múltiples solicitudes simultáneas (QA-04). |
| **DEC-02**  | Uso de Kafka para la comunicación asíncrona                | Kafka es adecuado para la comunicación entre microservicios debido a su capacidad de manejar grandes volúmenes de mensajes de manera eficiente. Esto satisface las preocupaciones sobre el rendimiento y la disponibilidad del sistema (CRN-01, CRN-02) al permitir que los servicios intercambien información sin bloquearse mutuamente, incluso durante picos de carga. Además, ayuda a mantener la integridad de las transacciones, lo que es clave para la seguridad de los pagos y reservas (QA-04, CRN-03). |
| **DEC-03**  | Escalabilidad horizontal mediante contenedores            | Utilizar contenedores para desplegar microservicios permite escalar horizontalmente los servicios, lo cual es esencial para manejar grandes volúmenes de tráfico de usuarios realizando pagos y reservas. Esto satisface la restricción de escalabilidad (CON-07) y las preocupaciones sobre el rendimiento del sistema (CRN-01, CRN-02). |
| **DEC-04**  | API Gateway con Nginx                                      | La implementación de un API Gateway a través de Nginx permite centralizar el manejo de peticiones y facilita la integración con sistemas externos, como Stripe para pagos. Esta arquitectura minimiza la latencia y optimiza la gestión del tráfico, abordando las preocupaciones de interoperabilidad (QA-08) y disponibilidad (QA-06). |
| **DEC-05**  | Integración con Stripe para pagos                          | Stripe se selecciona para gestionar las transacciones financieras debido a su seguridad, eficiencia y capacidad para cumplir con los estándares PCI-DSS. Esta integración resuelve la preocupación sobre la seguridad en el procesamiento de pagos (CRN-03) y asegura que las transacciones sean fiables y sin errores (QA-03). |
| **DEC-06**  | Uso de bases de datos relacionales y no relacionales (PostgreSQL y MongoDB) | La combinación de bases de datos relacionales (PostgreSQL) para datos estructurados y no relacionales (MongoDB) para datos más flexibles o no estructurados responde a la necesidad de manejar diferentes tipos de información (como pagos, reservas y servicios) de manera eficiente. Esto resuelve las preocupaciones sobre la consistencia de los datos entre diferentes sistemas de bases de datos (CRN-05) y optimiza el rendimiento en la carga de datos (QA-05). |




### Paso 5: Instanciar elementos de arquitectura, asignar responsabilidades y definir interfaces

| Código  | Decisión de diseño                                       | Fundamentación                                                                                                                                                                         |
|---------|----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **DEC-07**  | Asignación de microservicios para cada funcionalidad     | Los microservicios serán responsables de la gestión de diferentes funcionalidades clave del sistema: reservas, pagos, y visualización de departamentos. Esta asignación asegura la escalabilidad y la independencia de cada servicio, lo que facilita el manejo de cargas elevadas y la mejora del rendimiento. De esta forma, se asegura que las responsabilidades están claramente definidas y alineadas con los casos de uso. |
| **DEC-08**  | Definición de interfaces RESTful para comunicación       | Se definirán interfaces RESTful para la comunicación entre los microservicios. Estas interfaces serán estándares y simples, lo que permite una fácil integración entre los servicios y facilita la implementación de nuevas funcionalidades. La adopción de RESTful promueve la interoperabilidad (QA-08) y asegura que los servicios sean fácilmente accesibles y escalables. |
| **DEC-09**  | Uso de API Gateway para centralizar las peticiones       | Nginx será utilizado como el API Gateway para centralizar las peticiones de los usuarios. Este diseño permite que todas las solicitudes externas sean gestionadas de manera eficiente y que los microservicios estén aislados del tráfico directo, lo que mejora la seguridad y la disponibilidad. Además, reduce la complejidad de la interacción directa con los servicios internos, proporcionando un punto único de acceso. |
| **DEC-10**  | Integración con Stripe mediante SDK para pagos           | Stripe será integrado mediante su SDK, permitiendo que las transacciones sean gestionadas de forma segura y eficiente. El SDK facilita la implementación de pagos en línea, asegurando el cumplimiento con los estándares PCI-DSS y reduciendo el riesgo de errores o fraudes durante el proceso de pago. Este enfoque también asegura la consistencia en la gestión de pagos y facilita la monitorización de transacciones. |
| **DEC-11**  | Implementación de Kafka como intermediario de mensajes   | Kafka será usado como intermediario para la comunicación asíncrona entre los microservicios. Esto garantiza que las operaciones como la reserva de departamentos y el procesamiento de pagos se realicen de forma eficiente, sin bloquear otros servicios. Kafka asegura la fiabilidad en la transmisión de mensajes y permite la escalabilidad del sistema al manejar grandes volúmenes de datos. |
| **DEC-12**  | Asignación de PostgreSQL para gestión de datos estructurados | PostgreSQL será utilizado para almacenar datos estructurados, como la información de los usuarios, reservas y departamentos. Esta base de datos relacional es adecuada para garantizar la consistencia y la integridad de los datos en el sistema. Además, permite consultas complejas, lo que mejora la eficiencia en la gestión de grandes volúmenes de datos relacionados con las transacciones. |
| **DEC-13**  | MongoDB para almacenamiento de datos no estructurados    | MongoDB será utilizado para almacenar datos no estructurados o semi-estructurados, como registros de actividad y logs. Esta base de datos no relacional es flexible y se adapta a los cambios en el esquema de los datos, permitiendo una gestión eficiente de datos que no encajan fácilmente en un modelo relacional. Además, permite la escalabilidad horizontal para grandes cantidades de datos. |



### Paso 6: Bosquejar vistas y registrar decisiones de diseño

![Mapeo de modelo de datos](modelo_elementos.png)

### Paso 7: Revision de objetivos

| **No Abordado** | **Parcialmente Abordado** | **Completamente Abordado** | **Decisión de Diseño**  |
|------------------|---------------------------|----------------------------|-------------------------|
|                  | CU-01                     |                            | DEC-08, DEC-03          |
|                  | CU-02                     |                            | DEC-08, DEC-03          |
| CU-03            |                           |                            | -                       |
|                  | QA-01                     |                            | DEC-08                  |
|                  | QA-02                     |                            | DEC-08, DEC-03          |
|                  | QA-03                     |                            | DEC-08                  |
| CON-1            |                           |                            | -                       |
|                  | CON-3                     |                            | DEC-08, DEC-03          |
|                  | CON-4                     |                            | DEC-08, DEC-03          |
|                  | CRN-4                     |                            | DEC-08                  |
|                  | CRN-6                     |                            | DEC-08, DEC-03          |
|                  | CRN-7                     |                            | DEC-08                  |
|                  | CRN-1                     |                            | DEC-08                  |
